-load SPIR-V programs
-construct GfxPipeline (programs linked together)
-main loop timing
-ImGui
-Ability to create/destroy model instances arbitrarily
	-Some kind of 'MeshInstanceCache' ?
		-createMesh(modelVertices, etc) : meshId
			-perhaps supply a 'maxInstances' parameter on mesh creation
		-createInstance(meshId) : instanceId
		-destroyInstance(meshId, instanceId)
			-the act of 'destroying' an instance can simply be setting the mesh instance scale to be a v2f(0,0) ?
-Ability to construct arbitrary STATIC meshes and store them all in the same buffer, each with their own offset.
	-requires using 'glDrawArraysInstancedBaseInstance' with the 'baseinstance' set to the instance offset of this mesh in the instance-divided VBOs
		-each mesh is allowed a maximum # of instances to be drawn ?
-Allow meshes to have multiple 'primitive batches', each containing their own vertex data, primitive type, (potentially blend function?)
	-Create a circle mesh w/ an outline & a radian indicating the model's rotation
-Create a new method of instancing meshes instead of drawing a huge batch of 0-scale primitives
	-Maybe the API should work like this:
		-build static mesh data, return MeshId
		-submit draw request {MeshId, complete model specification}
			-if the draw request is new, start a new Batch {MeshId, first instance offset, # instances }
			-if the draw request is the same as the last, add the draw instance to the current batch
		-once per frame, flush batches.  Each batch is just a bunch of copies of a single mesh.  Each batch requires the same # of draw calls as the # of primitive batches for the mesh.  The most optimal usage is to submit draw requests already Z-ordered, and with all the same meshes requested contiguously for each layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DONE ^^^^^^^^^^^^^^^^^
	-Nope, the above method is too slow because it requires an extra pass over the model transform components (to send them into the mesh instance manager object), and this cannot be multi-threaded because we would lose draw order.  
		-It's probably best to pre-define max instance # per-mesh like before, keep model transform components contiguous, and just set the instance count per-mesh.
		-remove CPU data buffers from InstancedMeshCache
		-Instance creation/destruction is handled by whatever system is holding the CPU model transform data
		-This means that each frame, instead of performing a single VBO update on each model transform component, we perform one sub-update per mesh aligned to the mesh's designated instance VBO range
-Create a "RenderState" object that keeps track of what Renderer & GfxProgram is currently in use so that whenever we attempt to set these to be used, we don't have to keep actually calling the opengl functions if that object is already set
-Simulation object - hold the entire current state of the simulation & interface with it (control input, render output, execute a logical step)
-Allow view to be moved around (and zoomed?)
-Create a simulation with simple circle objects moving around a box
	-if the objects leave the box, destroy it and spawn a new actor at a random location w/ random speed
-Test performance of setting model translation/rotation to random mesh instance offsets
-TEXTURED meshes
-Figure out how to have alpha/additive blending using pre-multiplied alpha textures
	https://github.com/endless-sky/endless-sky/wiki/BlendingModes
	https://www.khronos.org/opengl/wiki/Blending
-COLLISION DETECTION
-SPATIAL PARTITIONER
-Figure out the stupid GLM memory alignment issue I had in GlobalUniformBuffer
	-do I even need the GLM_FORCE_ALIGNED_GENTYPES shit in the pch?